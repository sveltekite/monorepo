#!/usr/bin/env node

import { Command } from 'commander'
import inquirer from 'inquirer'
import chalk from 'chalk'
import fs from 'fs/promises'
import path from 'path'
import { CodeGenerator } from './generator.js'
import { SchemaParser } from './schema-parser.js'

const program = new Command()

program
  .name('sveltekit-sails')
  .description('Generate full-stack SvelteKit applications from schema definitions')
  .version('1.0.0')

program
  .command('init')
  .description('Initialize a new SvelteKit Sails project with interactive schema builder')
  .option('-o, --output <path>', 'Output directory', '.')
  .action(async (options) => {
    console.log(chalk.blue('üöÄ Welcome to SvelteKit Sails!'))
    console.log('Let\'s build your schema interactively...\n')

    const schema = await buildSchemaInteractively()
    const yamlContent = generateYamlFromSchema(schema)

    // Save schema.yaml
    await fs.writeFile(path.join(options.output, 'schema.yaml'), yamlContent)
    console.log(chalk.green('‚úÖ Created schema.yaml'))

    // Generate code
    const generator = new CodeGenerator(schema, options.output)
    await generator.generateAll()

    console.log(chalk.green('\nüéâ Project generated successfully!'))
    console.log(chalk.cyan('\nNext steps:'))
    console.log('1. Install dependencies: npm install')
    console.log('2. Start development server: npm run dev')
    console.log('3. Customize your entity classes and components')
  })

program
  .command('generate')
  .description('Generate code from existing schema.yaml file')
  .argument('<schema>', 'Path to schema.yaml file')
  .option('-o, --output <path>', 'Output directory', '.')
  .action(async (schemaPath, options) => {
    try {
      console.log(chalk.blue('üìù Generating from schema file...'))

      const generator = await CodeGenerator.fromYamlFile(schemaPath, options.output)
      await generator.generateAll()

      console.log(chalk.green('‚úÖ Code generated successfully!'))
    } catch (error) {
      console.error(chalk.red('‚ùå Error generating code:'), error.message)
      process.exit(1)
    }
  })

program
  .command('add-entity')
  .description('Add a new entity to existing schema')
  .option('-s, --schema <path>', 'Path to schema.yaml file', 'schema.yaml')
  .option('-o, --output <path>', 'Output directory', '.')
  .action(async (options) => {
    try {
      // Load existing schema
      const existingYaml = await fs.readFile(options.schema, 'utf-8')
      const existingSchema = SchemaParser.parseYAML(existingYaml)

      console.log(chalk.blue('‚ûï Adding new entity to existing schema...'))

      const newEntity = await buildEntityInteractively()

      // Add to existing schema and regenerate
      const updatedYaml = existingYaml + '\n' + generateEntityYaml(newEntity.name, newEntity.definition)
      await fs.writeFile(options.schema, updatedYaml)

      const generator = await CodeGenerator.fromYamlFile(options.schema, options.output)
      await generator.generateAll()

      console.log(chalk.green(`‚úÖ Added entity '${newEntity.name}' successfully!`))
    } catch (error) {
      console.error(chalk.red('‚ùå Error adding entity:'), error.message)
      process.exit(1)
    }
  })

program
  .command('validate')
  .description('Validate schema.yaml file')
  .argument('<schema>', 'Path to schema.yaml file')
  .action(async (schemaPath) => {
    try {
      console.log(chalk.blue('üîç Validating schema...'))

      const yamlContent = await fs.readFile(schemaPath, 'utf-8')
      const schema = SchemaParser.parseYAML(yamlContent)

      console.log(chalk.green('‚úÖ Schema is valid!'))
      console.log(`üìä Found ${Object.keys(schema.entities).length} entities`)
      console.log(`üîó Found ${Object.keys(schema.joinTables).length} join tables`)

      // Show summary
      for (const [entityName, config] of Object.entries(schema.entities)) {
        const fieldCount = Object.keys(config.fields).length
        const relationCount = Object.keys(config.relations).length
        console.log(`   ${entityName}: ${fieldCount} fields, ${relationCount} relations`)
      }
    } catch (error) {
      console.error(chalk.red('‚ùå Schema validation failed:'), error.message)
      process.exit(1)
    }
  })

async function buildSchemaInteractively() {
  const entities = {}

  while (true) {
    const { entityName } = await inquirer.prompt([
      {
        type: 'input',
        name: 'entityName',
        message: 'Enter entity name (or press Enter to finish):',
        validate: (input) => {
          if (!input) return true // Allow empty to finish
          if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(input)) {
            return 'Entity name must start with a letter and contain only letters and numbers'
          }
          if (entities[input]) {
            return 'Entity name already exists'
          }
          return true
        }
      }
    ])

    if (!entityName) break

    console.log(chalk.cyan(`\nDefining fields for ${entityName}:`))
    const entityDef = await buildEntityDefinition()
    entities[entityName] = entityDef
  }

  if (Object.keys(entities).length === 0) {
    console.log(chalk.yellow('No entities defined. Creating a sample schema...'))
    return {
      entities: {
        article: {
          title: 'string',
          body: 'text',
          userId: 'user',
          tags: ['tag']
        },
        user: {
          name: 'string',
          email: 'email'
        },
        tag: {
          name: 'string',
          color: 'color'
        }
      },
      joinTables: {}
    }
  }

  return SchemaParser.parseYAML(generateYamlFromEntities(entities))
}

async function buildEntityDefinition() {
  const fields = {}

  while (true) {
    const { fieldName } = await inquirer.prompt([
      {
        type: 'input',
        name: 'fieldName',
        message: 'Enter field name (or press Enter to finish):',
        validate: (input) => {
          if (!input) return true // Allow empty to finish
          if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(input)) {
            return 'Field name must start with a letter and contain only letters and numbers'
          }
          if (fields[input]) {
            return 'Field name already exists'
          }
          return true
        }
      }
    ])

    if (!fieldName) break

    const { fieldType } = await inquirer.prompt([
      {
        type: 'list',
        name: 'fieldType',
        message: `Select type for ${fieldName}:`,
        choices: [
          { name: 'String (short text)', value: 'string' },
          { name: 'Text (long text)', value: 'text' },
          { name: 'Number', value: 'number' },
          { name: 'Boolean (true/false)', value: 'boolean' },
          { name: 'Date', value: 'date' },
          { name: 'Email', value: 'email' },
          { name: 'Color', value: 'color' },
          { name: 'Relation to other entity', value: 'relation' }
        ]
      }
    ])

    if (fieldType === 'relation') {
      const { relationType } = await inquirer.prompt([
        {
          type: 'list',
          name: 'relationType',
          message: `Select relation type for ${fieldName}:`,
          choices: [
            { name: 'Belongs to (foreign key)', value: 'belongsTo' },
            { name: 'Many to many (array notation)', value: 'manyToMany' }
          ]
        }
      ])


      const { targetEntity } = await inquirer.prompt([
        {
          type: 'input',
          name: 'targetEntity',
          message: 'Enter target entity name:',
          validate: (input) => input ? true : 'Target entity name is required'
        }
      ])

      if (relationType === 'manyToMany') {
        fields[fieldName] = [targetEntity]
      } else {
        fields[fieldName] = targetEntity
      }
    } else {
      fields[fieldName] = fieldType
    }
  }

  return fields
}

async function buildEntityInteractively() {
  const { entityName } = await inquirer.prompt([
    {
      type: 'input',
      name: 'entityName',
      message: 'Enter entity name:',
      validate: (input) => {
        if (!input) return 'Entity name is required'
        if (!/^[a-zA-Z][a-zA-Z0-9]*$/.test(input)) {
          return 'Entity name must start with a letter and contain only letters and numbers'
        }
        return true
      }
    }
  ])

  console.log(chalk.cyan(`\nDefining fields for ${entityName}:`))
  const definition = await buildEntityDefinition()

  return { name: entityName, definition }
}

function generateYamlFromEntities(entities) {
  let yaml = ''
  for (const [entityName, fields] of Object.entries(entities)) {
    yaml += `${entityName}:\n`
          for (const [fieldName, fieldType] of Object.entries(fields)) {
      if (Array.isArray(fieldType)) {
        yaml += `  ${fieldName}: [${fieldType[0]}]\n`
      } else {
        yaml += `  ${fieldName}: ${fieldType}\n`
      }
    }
    yaml += '\n'
  }
  return yaml.trim()
}

function generateEntityYaml(entityName, definition) {
  let yaml = `${entityName}:\n`
  for (const [fieldName, fieldType] of Object.entries(definition)) {
    if (Array.isArray(fieldType)) {
      yaml += `  ${fieldName}: [${fieldType[0]}]\n`
    } else {
      yaml += `  ${fieldName}: ${fieldType}\n`
    }
  }
  return yaml
}

function generateYamlFromSchema(schema) {
  return generateYamlFromEntities(schema.entities || schema)
}

// Error handling
process.on('unhandledRejection', (error) => {
  console.error(chalk.red('‚ùå Unhandled error:'), error)
  process.exit(1)
})

program.parse()
